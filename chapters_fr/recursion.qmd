---
title: "Division Récursive"
---

L'algorithme d'apprentissage des Decision Trees est un algorithme **récursif**.

## Fonctions

La récursion est une idée fascinante qui s'appuie sur le concept de **fonction**. En programmation, les fonctions sont des morceaux de code réutilisables qui exécutent une portion de code.

Par exemple, la fonction suivante additionne deux nombres et retourne le résultat :

```{.plaintext .number-lines}
Additionneur(a, b):
    resultat = a + b
    return resultat
```

C'est un programme simple représenté en pseudocode, un langage entre le langage naturel (comme le français) et le code.

::: {.callout-note collapse="true"}
## Qu'est-ce que le pseudocode ?

Le pseudocode est un langage à mi-chemin entre le langage naturel et le code.

Les langages naturels sont des langues comme le français, l'anglais ou le chinois que nous utilisons pour communiquer les uns avec les autres. Ils sont à la fois :

- ambigus : le même mot peut avoir deux significations ou plus
- dépendants du contexte : la signification d'un mot dépend de son contexte

Le code est un langage non ambigu et indépendant du contexte. Nous l'utilisons pour définir des programmes à exécuter par des ordinateurs.

Le pseudocode est plus proche du langage naturel et nous permet de communiquer des programmes et des idées.

:::

En parcourant cette fonction ligne par ligne :

1. Définit une nouvelle fonction appelée `Additionneur`, qui prend deux paramètres d'entrée `a` et `b`
2. Additionne les deux paramètres et stocke le résultat dans la variable `resultat`
3. Retourne la variable `resultat` à l'utilisateur

En code Python, cette définition de fonction ressemblerait à ceci :

```python
def additionneur(a,b):
    resultat = a + b
    return resultat
```

Une fois définie, cette fonction peut être appelée encore et encore, sans avoir à copier-coller de code. Les fonctions sont un élément fondamental de la programmation.

Pour appeler cette fonction en Python, vous pourriez écrire `additionneur(2,3)` et `5` serait le résultat.

## Récursion

En informatique, la récursion se produit lorsqu'une **fonction s'appelle elle-même**, directement ou indirectement, pour résoudre un problème en le décomposant en sous-problèmes plus petits.

C'est la définition technique, ce chapitre rendra ce concept plus concret.

Prenons la suite de Fibonacci comme exemple :

0, 1, 1, 2, 3, 5, 8, ...

Dans la suite de Fibonacci, le $n^{ième}$ terme est la somme des deux précédents, les deux premiers termes de la série étant 0 et 1.

Pour calculer le 3ème terme, nous additionnons les deux premiers nombres : 0 + 1 = 1
Pour calculer le 4ème, nous additionnons le deuxième et le troisième nombre : 1 + 1 = 2

Nous pouvons continuer ce processus :

- 5ème : 1 + 2 = 3
- 6ème : 2 + 3 = 5

:::{.exercise #exr-fib}
Calculez le 7ème et le 8ème terme de la suite de Fibonacci.
:::

Pour rendre ce processus plus général, nous pouvons calculer le $n^{ième}$ terme de Fibonacci, $Fibonacci(n)$, avec l'expression suivante :

$$
Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
$$

Cela pourrait être déroutant, car une fonction est utilisée dans sa propre définition. Pourtant, cela signifie simplement que chaque terme est la somme des **deux précédents** dans la série.

Cette expression pourrait aussi être transformée en programme suivant, qui calculerait le $n^{ième}$ terme de Fibonacci :

```{.plaintext .number-lines}
Fibonacci(n):
    if n == 0: return 0
    if n == 1: return 1
    return Fibonacci(n-1) + Fibonacci(n-2)
```

Si vous n'avez jamais vu de pseudocode auparavant, cela peut sembler intimidant. Cela signifie simplement ce qui suit (les numéros dans la liste correspondent au numéro de ligne dans l'extrait de code) :

1. Définit une nouvelle fonction appelée `Fibonacci`, cette fonction prend un paramètre appelé `n`
2. Si ce paramètre est 0, la fonction retourne 0
3. Si ce paramètre est 1, la fonction retourne 1
4. Sinon, la fonction doit retourner la somme des deux termes de Fibonacci précédents, représentés par `Fibonacci(n-1)` et `Fibonacci(n-2)`

La dernière ligne est la récursion en action : une fonction qui s'appelle elle-même ! Pour obtenir `Fibonacci(3)` nous devons calculer `Fibonacci(2)` et `Fibonacci(1)`. Pour obtenir `Fibonacci(2)`, nous avons besoin de `Fibonacci(1)` et `Fibonacci(0)`. C'est exactement ce qu'est la récursion.

Note : En informatique, les listes commencent à l'index 0. Donc le premier terme est à l'index 0, le second à l'index 1, etc.

Si vous trouvez cela déroutant, vous n'êtes pas seul. Calculons un exemple avec `Fibonacci(3)`, qui retournera le 4ème terme de la série de Fibonacci (en commençant à l'index 0). Ce qui suit exécutera la fonction ligne par ligne :

```{.plaintext .number-lines}
Fibonacci(3)
3 n'est ni 0 ni 1
Appel de Fibonacci(2) et Fibonacci(1)
    Fibonacci(2)
    2 n'est ni 0 ni 1
        Appel de Fibonacci(1) et Fibonacci(0)
            Fibonacci(1)
            Retourne 1
            Fibonacci(0)
            Retourne 0
    Retourne 1 + 0 = 1
    Fibonacci(1)
    Retourne 1
Retourne 1 + 1 = 2
```

Dans l'exemple ci-dessus, chaque indentation représente un niveau de récursion.

### Division Récursive

La logique de division d'un Decision Tree fonctionne de manière similaire. Elle continue à diviser les sous-groupes jusqu'à ce que la condition d'arrêt soit atteinte. Elle pourrait être définie en pseudocode comme suit :

```{.plaintext .number-lines}
Diviser(Groupe):
    Si le groupe est "pur" ne rien faire
    Trouver la meilleure caractéristique et valeur de division
    Diviser le groupe en deux : Sous-groupe A, et Sous-groupe B
    Appliquer Diviser(SousGroupeA) et Diviser(SousGroupeB)
```

Dans le programme défini ci-dessus, la ligne 2 définit le critère d'arrêt. Dans le cas où le groupe ne contient qu'une seule classe, la fonction se termine. Sinon, elle continue la récursion avec les lignes 3-5. Elle continue à diviser les données.

Appliquons cette logique aux données d'exemple étape par étape :

```plaintext
Diviser(Dataset)  
Le groupe contient deux classes, procéder à la division
La meilleure division est trouvée à x1 = 2
Divise le Dataset en Groupes A et B
Appelle Diviser(Groupe A) et Diviser(Groupe B)
```

![Division du dataset](/images/trees/split1_AB.png){width=40%}

```plaintext
    Diviser(Groupe B)  
    Procéder à la division car le groupe contient deux classes  
    La meilleure division est trouvée à x2 = 1
    Divise B en Groupes C et D
    Appelle Diviser(Groupe C) et Diviser(Groupe D)    
    :::
```

![Division du Groupe B](/images/trees/split2_ACD.png){width=40%}


```plaintext
        Diviser(Groupe C)
        Ne fait rien car le Groupe C ne contient qu'une seule classe
        Diviser(Groupe D)
        Ne fait rien car le Groupe D ne contient qu'une seule classe
    Diviser(Groupe A)  
    Procéder à la division car le groupe contient deux classes  
    La meilleure division est trouvée à x2 = 2
    Divise le Groupe A en Groupes E et F
    Appelle Diviser(Groupe E) et Diviser(Groupe F)
```

![Division du Groupe A](/images/trees/split3_EFCD.png){width=40%}

```plaintext
        Diviser(Groupe E)
        Ne fait rien car le Groupe E ne contient qu'une seule classe
        Diviser(Groupe F)
        Ne fait rien car le Groupe F ne contient qu'une seule classe
L'algorithme se termine
```

En informatique, ce n'est pas de la récursion si vous n'avez pas mal à la tête en y pensant.

## Révision de l'Algorithme d'Apprentissage des Decision Trees

Le chapitre précédent a passé en revue deux concepts fondamentaux de l'apprentissage des Decision Trees :

1. **Récursion** : processus qui s'appelle lui-même
2. **Coefficient d'Impureté de Gini** : une façon de noter différentes divisions de données

L'algorithme d'apprentissage des Decision Trees peut alors être résumé comme suit :

```{.plaintext .number-lines}
Diviser(Groupe)
    Si le groupe ne contient qu'une seule classe ou est trop petit, ne rien faire
    Trouver la meilleure division en utilisant le critère d'Impureté de Gini
    Diviser les données en deux sous-groupes
    Appliquer la fonction Diviser aux deux sous-groupes résultants
```

Cette fonction construira un arbre, c'est-à-dire une collection de divisions et de nœuds feuilles, jusqu'à ce qu'il n'y ait plus de moyen de diviser les données. C'est tout !

Pour prédire pour une nouvelle observation, elle peut être passée dans l'arbre. La prédiction résultante sera l'étiquette qui constitue la majorité des observations dans la feuille.

## Conclusion

Ce chapitre a introduit le concept fondamental de la **récursion**. La récursion se produit lorsqu'une fonction s'appelle elle-même. Dans le cas des Decision Trees, la fonction de division divise d'abord le dataset en deux groupes (voir [chapitre précédent](splitting-maths.qmd)), puis **s'appelle elle-même** sur chacun des sous-groupes. Cela continue jusqu'à ce qu'aucun groupe supplémentaire ne puisse être divisé.

Le prochain chapitre ajoutera quelques nuances et rassemblera l'ensemble de l'algorithme des Decision Trees.

## Solutions
:::{.solution #sol-fib}
@exr-fib

- 7ème : $3 + 5 = 8$
- 8ème : $5 + 8 = 13$
:::
